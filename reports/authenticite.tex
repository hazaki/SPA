\chapter{Authenticité et Intégrité}
Après avoir présenté le procédé, nous allons détailler davantage les outils utilisés pour le satisfaire.

Pour palier à la faiblesse du \emph{Port Knocking}, et afin qu'une simple écoute du réseau ne suffise pas à mettre en péril ce schéma, la pérénnité de cette méthode va reposer sur l'authentification des clients. En effet il est nécessaire de vérifier que l'acceptation d'un paquet par le pare-feu est bien effectuée par un client légitime.

A contrario du \emph{Port Knocking} qui supposait que seul un client autorisé pouvait connaître la séquence de coups, ici l'authenticité va se faire grâce à des clés prépartagées. En effet, le serveur va partager une clé avec chacun des ses clients, chaque clé étant différente des autres. 
Le client génère alors un paquet SPA chiffré avec cette clé, le serveur SPA le déchiffre avec la même clé. Il détermine la légitimité de la requête et si les champs sont valides, l'intégrité grâce au système de hachage

Si la demande est valide, le client sera considéré comme authentifié auprès du serveur et il pourra communiquer avec lui sur le port fourni.

\section{Chiffrement}
Pour le chiffrement, nous utiliserons le standard du chiffrement symétrique, AES. 

Pour choisir le mode d'opération cryptographique, nous avons du choisir entre ECB, CBC, CFB, OFB et CTR. 
A la vue du peu d'information à chiffrer (numéro de port, temps d'ouverture et protocole de transport) un chiffrement par flux ne se justifiait pas.
De plus, sachant que ECB connait des vulnérabilités quant à l'intégrité et la protection des données puisqu'il est sensible aux attaques par répétition (deux blocs avec le même contenu seront chiffrés de la même manière).
Par ailleurs, OFB est fragile vis-à-vis des attaques à clair connu et CTR est fragile si l'attaquant connait l'IV (ce qui sera le cas ici étant donné que celui-ci sera envoyé en clair).
Nous choisirons donc CBC.


Nous désirons que le client puisse choisir le port serveur avec lequel il veut communiquer, le protocole de transport utilisé (tcp ou udp) ainsi que le temps d'accès au port (en maintenant un temps maximal d'ouverture de port).

\section{Champ \textbf{\emph{IP}} du paylaod}

De plus, afin de s'assurer de l'authenticité de l'émetteur du paquet, celui-ci doit introduire son adresse IP dans le champ de données chiffré. Ainsi, en comparant cette donnée et le header du paquet ip, il sera possible de voir si les informations sont cohérentes et donc authentiques (un attaquant n'étant pas en mesure de fournir un chiffré valide sans la clé adéquate). 
De plus,cette comparaison d'adresse nous permet de déterminer l'intégrité du message envoyé.
En effet, un utilisateur légitime construit naturellement un paquet avec ces deux champs IP identiques. Un usurpateur pourra alors être démasqué si sa requête ne respecte pas cela.

\section{Hachage}

%\section{\emph{\textbf{O}ne \textbf{T}ime \textbf{P}assword}}
%En sachant que la structure des messages est connue et que leur contenu peut l'être aussi (on ne prétend pas ici garder ces informations secrètes mais seulement authentiques), il semble nécessaire de changer régulièrement de mot de passe pour que celui-ci ne soit pas affaibli par une attaque a clair connu, par exemple.

%Nous utiliserons donc le mécanisme des OTP pour pallier à ce problème. En effet, le client aura une graine à partir de laquelle générer des clés à usage unique. De son côté le serveur aura une graine par client qu'il fera évoluer de la même façon que le client.
%\\
%Pour cela, plusieurs types d'OTP existent :
%\begin{itemize}
%\item Ceux basés sur \textbf{le temps}. Le client et le serveur doivent pour cela être synchronisé afin de déterminer simultanément la clé à utiliser.  
%\item Ceux basés sur \textbf{des algorithmes mathématiques} qui créeront le nouveau mot de passe à partir du précédent ou d'un challenge.
%\end{itemize}
%Dans le cadre du SPA, il fallait qu'il n'y ait pas d'autre dialogue entre le client et pare-feu que celui déjà connu, ainsi nous avons choisi d'utiliser les HOTP. Le client et le serveur partagent une graine et un compteur, le mot de passe courant sera le résultat du hmac entre ces deux valeurs. A chaque nouveau paquet, le compteur évoluera.
